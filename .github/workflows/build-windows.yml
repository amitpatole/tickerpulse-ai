```yaml
name: Build Windows Installer

# Triggered by two paths:
#   1. workflow_run on "CI" — fires after CI completes on a version tag (v*).
#      The job condition ensures we only build when CI passed and the head ref
#      is a semver tag (starts with 'v' and contains '.'), so routine branch
#      merges to main do not spin up expensive Windows runners.
#   2. workflow_dispatch — manual builds for testing the installer pipeline.
#
# The previous `push: tags: v*` trigger is replaced by workflow_run so that
# the Windows installer build is always gated on green CI (including the
# electron-type-check and compile verification jobs).
on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g. 3.0.0)'
        required: false
        default: ''

permissions:
  contents: write

jobs:
  build:
    runs-on: windows-latest
    timeout-minutes: 45
    # For workflow_run: only build when CI passed on a version tag (e.g. v3.0.0).
    # The head_branch for a tag-triggered CI run is the tag name itself.
    # The startsWith + contains guard prevents feature branches like 'v2-redesign'
    # from accidentally triggering installer builds.
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' &&
       startsWith(github.event.workflow_run.head_branch, 'v') &&
       contains(github.event.workflow_run.head_branch, '.'))

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # For workflow_run, check out the exact commit that CI validated.
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Set up Node.js 24
        uses: actions/setup-node@v4
        with:
          node-version: '24'

      # ── Stage 1: Build Backend with PyInstaller ──
      - name: Install Python dependencies
        run: |
          pip install -r backend/requirements.txt
          pip install pyinstaller

      - name: Build backend (PyInstaller)
        run: |
          pyinstaller backend/tickerpulse.spec --distpath build/backend --workpath build/temp/backend -y

      - name: Verify backend artifact
        run: |
          if (!(Test-Path "build\backend\tickerpulse-backend\tickerpulse-backend.exe")) {
            Write-Host "ERROR: Backend build failed — exe not found" -ForegroundColor Red
            exit 1
          }
          $Size = [math]::Round((Get-ChildItem "build\backend" -Recurse | Measure-Object Length -Sum).Sum / 1MB, 1)
          Write-Host "Backend build complete ($Size MB)" -ForegroundColor Green

      # ── Stage 2: Build Frontend (Next.js Standalone) ──
      - name: Install frontend dependencies
        working-directory: frontend
        run: npm install --legacy-peer-deps

      - name: Build frontend (Next.js standalone)
        working-directory: frontend
        run: npm run build

      - name: Assemble frontend bundle
        run: |
          New-Item -ItemType Directory -Force -Path "build\frontend" | Out-Null

          # Next.js may nest under workspace name
          $StandalonePath = "frontend\.next\standalone"
          $ServerPaths = @(
              "$StandalonePath\server.js",
              "$StandalonePath\frontend\server.js"
          )

          $FoundPath = $null
          foreach ($p in $ServerPaths) {
              if (Test-Path $p) {
                  $FoundPath = Split-Path $p -Parent
                  break
              }
          }

          if (-not $FoundPath) {
              Write-Host "ERROR: standalone server.js not found" -ForegroundColor Red
              exit 1
          }

          Copy-Item -Recurse -Force "$FoundPath\*" "build\frontend"

          # Copy static assets (standalone does not include these)
          New-Item -ItemType Directory -Force -Path "build\frontend\.next\static" | Out-Null
          Copy-Item -Recurse -Force "frontend\.next\static\*" "build\frontend\.next\static\"

          # Copy public assets
          if (Test-Path "frontend\public") {
              Copy-Item -Recurse -Force "frontend\public" "build\frontend\public"
          }

      - name: Download Node.js Windows binary
        run: |
          $NodeVersion = "v22.14.0"
          $NodeUrl = "https://nodejs.org/dist/$NodeVersion/win-x64/node.exe"
          Write-Host "Downloading Node.js $NodeVersion..."
          Invoke-WebRequest -Uri $NodeUrl -OutFile "build\frontend\node.exe"

      # ── Stage 3: Compile Electron TypeScript ──
      - name: Install Electron dependencies
        working-directory: electron
        run: npm install

      - name: Compile Electron TypeScript
        working-directory: electron
        run: npx tsc

      # ── Stage 4: Package Windows Installer (NSIS) + Publish ──
      - name: Build installer with electron-builder
        working-directory: electron
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Derive the version from the git tag (e.g. refs/tags/v3.78.0 -> 3.78.0).
          # This ensures the installer filename and electron-updater metadata always
          # match the release tag, regardless of what package.json says.  Using
          # --config.extraMetadata.version overrides the version for this build only.
          $TagVersion = ""
          $HeadBranch = "${{ github.event.workflow_run.head_branch }}"
          $RefName = "${{ github.ref_name }}"

          # Resolve version from whichever trigger fired
          if ($HeadBranch -match '^v\d') {
            $TagVersion = $HeadBranch -replace "^v", ""
            Write-Host "Building version from workflow_run tag: $TagVersion" -ForegroundColor Cyan
          } elseif ($RefName -match '^v\d') {
            $TagVersion = $RefName -replace "^v", ""
            Write-Host "Building version from ref_name: $TagVersion" -ForegroundColor Cyan
          }

          if ($TagVersion) {
            $PkgPath = "package.json"
            $Pkg = Get-Content $PkgPath | ConvertFrom-Json
            $Pkg.version = $TagVersion
            $Pkg | ConvertTo-Json -Depth 10 | Set-Content $PkgPath
          }

          $IsTagBuild = ($HeadBranch -match '^v\d') -or ($RefName -match '^v\d')
          if ($IsTagBuild) {
            Write-Host "Tag build detected — publishing to GitHub Releases" -ForegroundColor Green
            npx electron-builder --win --config electron-builder.yml --publish always
          } else {
            Write-Host "Non-tag build — artifact only" -ForegroundColor Yellow
            npx electron-builder --win --config electron-builder.yml
          }

      - name: Locate installer
        id: find-exe
        run: |
          $Exe = Get-ChildItem "dist-electron" -Filter "*.exe" | Select-Object -First 1
          if ($Exe) {
              $Size = [math]::Round($Exe.Length / 1MB, 1)
              Write-Host "Installer: $($Exe.Name) ($Size MB)" -ForegroundColor Green
              echo "EXE_NAME=$($Exe.Name)" >> $env:GITHUB_OUTPUT
              echo "EXE_PATH=dist-electron/$($Exe.Name)" >> $env:GITHUB_OUTPUT
          } else {
              Write-Host "ERROR: No installer .exe found in dist-electron/" -ForegroundColor Red
              exit 1
          }

      # ── Upload artifact (available for all triggers) ──
      - name: Upload installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: TickerPulse-AI-Windows-Installer
          path: ${{ steps.find-exe.outputs.EXE_PATH }}
          retention-days: 30
```